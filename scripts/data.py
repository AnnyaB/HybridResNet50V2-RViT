
# scripts/data.py
#
# This file defines a PyTorch Dataset that reads image paths and labels from a CSV.
# Those CSV files are expected to be generated by dataset_prep.py and look like:
#   data/splits/tightcrop/{train,val,test}.csv
#
# Each CSV row should have:
#   - image_path  -> where the MRI image lives on disk
#   - class       -> one of: glioma / meningioma / pituitary / notumor

import os                     # I use this to test whether a path exists on disk
from pathlib import Path      # nicer path joining across different OSes (Windows/Linux/Mac)

import pandas as pd           # CSV reading and row access
from PIL import Image         # image loading (PIL is standard for torchvision)

import torch                  # tensors and random generators
from torch.utils.data import Dataset  # base class for PyTorch datasets
import torchvision.transforms as T    # common image transforms and augmentation


class AddGaussianNoise:
    
    """
    Custom transform: sometimes add small Gaussian noise to a tensor image.
    I apply it only during training (see build_transforms), to improve robustness.
    """
    def __init__(self, std=0.02, p=0.5):
        self.std = std  # how strong the noise is
        self.p = p      # probability of applying noise on a given sample

    def __call__(self, x):
        # x is expected to be a torch tensor in [0,1] already (after ToTensor()).

        # Drew a random number in [0,1). If it's greater than p, skip noise.
        # Note: this logic means "apply noise with probability p".
        if torch.rand(1).item() > self.p:
            return x

        # Created noise with same shape as x: N(0, std^2).
        noise = torch.randn_like(x) * self.std

        # Added the noise to the image tensor.
        x = x + noise

        # Clamped back to valid pixel range [0,1] so we don't create weird values.
        return torch.clamp(x, 0.0, 1.0)


def _resolve_path(p, project_root):
    
    """
    Tried to make CSV image paths portable.

    Sometimes the CSV contains absolute paths from a different machine
    (for instance., my Mac). On Kaggle those paths won't exist.

    This function tries a few reasonable conversions:
      1) If the path exists as-is, use it.
      2) If it contains /data/processed/, rebuild under project_root.
      3) Otherwise try treating it as relative to project_root.
      4) If all fail, return original and let __getitem__ fail (it's for my debugging).
    """

    # If the path is already valid on this machine, I'm done.
    if os.path.exists(p):
        return p

    # Converted backslashes to forward slashes so Windows-style paths don’t break parsing.
    p2 = str(p).replace("\\", "/")

    # This is a marker folder that might appear in old absolute paths.
    key = "/data/processed/"

    # Finding where that marker occurs in the path.
    idx = p2.find(key)

    # If I found the marker, I tried rebuilding a path relative to project_root.
    if idx != -1:
        # idx+1 removes a leading '/' so that Path(project_root) / rel joins properly
        rel = p2[idx + 1:]
        cand = str(Path(project_root) / rel)

        # If that candidate exists, used it.
        if os.path.exists(cand):
            return cand

    # Fallback, tried treating the whole p2 as a path relative to project_root.
    cand2 = str(Path(project_root) / p2)
    if os.path.exists(cand2):
        return cand2

    # Final fallback: return original path.

    # This will likely fail in Image.open(), but that can be good for debugging.
    return p


def build_transforms(train, mean, std):
    
    """
    Built a torchvision transform pipeline.
    - If train=True: add random augmentations.
    - Always: ToTensor and Normalize.

    mean/std should be sequences of 3 values (for RGB channels),
    for instance. mean=(0.485,0.456,0.406), std=(0.229,0.224,0.225).
    """
    ops = []  # I collected operations in a list, then compose them

    if train:
        # Light augmentations to help generalization (don’t overfit exact poses).
        ops.extend([
            T.RandomRotation(degrees=15),                 # rotate image randomly within +/- 15 degrees
            T.RandomHorizontalFlip(p=0.5),                # flip half the time
            T.RandomAffine(degrees=0, translate=(0.05, 0.05)),  # shift image slightly (up to 5% of width/height)
        ])

    # Converted PIL image to float torch tensor:
    # shape becomes [C,H,W] and values become [0,1].
    ops.extend([T.ToTensor()])

    if train:
        # Added small noise sometimes, only for training.
        ops.append(AddGaussianNoise(std=0.02, p=0.5))

    # Normalize channels: (x - mean) / std
    # This helps training stability and matches expected input stats for many backbones.
    ops.append(T.Normalize(mean=mean, std=std))

    # Composed into a single callable transform.
    return T.Compose(ops)


class BrainMRICSV(Dataset):
    
    """
    A PyTorch Dataset that reads MRI image paths and labels from a CSV file.

    Returns:
      x       : transformed image tensor [3,H,W]
      y       : integer class id
      img_path: resolved image path (useful for debugging / visualization)
    """
    def __init__(self, csv_path, class_names, transform, project_root):
        
        # Loaded the CSV into a dataframe so we can index rows easily.
        self.df = pd.read_csv(csv_path)

        # Kept class names in a stable order (this defines label -> index mapping).
        self.class_names = class_names

        # Created mapping like {"glioma":0, "meningioma":1, ...}
        self.class_to_idx = {c: i for i, c in enumerate(class_names)}

        # Stored transform pipeline (train/val/test versions).
        self.transform = transform

        # Used by _resolve_path() to rebuild paths in a portable way.
        self.project_root = project_root

    def __len__(self):
        
        # Dataset length = number of rows in CSV.
        return len(self.df)

    def __getitem__(self, idx):
        # Grabbed the row at position idx.
        row = self.df.iloc[idx]

        # Resolved the image path to something valid on this machine.
        img_path = _resolve_path(row["image_path"], self.project_root)

        # Read class label as a string, e.g. "glioma".
        y_str = row["class"]

        # Converted string label -> integer index.
        y = self.class_to_idx[y_str]

        # Loaded the image from disk and force RGB (3 channels).
        img = Image.open(img_path).convert("RGB")

        # Applied transforms: augment (if training), tensor conversion, normalization, etc.
        x = self.transform(img)

        # Returned tensor, label index, and path (path helps debugging and explainability later).
        return x, y, img_path